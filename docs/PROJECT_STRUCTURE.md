# Project Structure

This document outlines the directory organization for the Warehouse Employee Management System, distinguishing between the development repository and the deployed project instances.

## 1. Development Repository Structure

The development repository contains the source code, tests, build scripts, and the bootstrapper utility.

```
simple-employee-manager/                # Root of the git repository
│
├── bootstrapper/                       # Project generator utility
│   ├── __init__.py
│   ├── main.py                         # Bootstrapper entry point
│   ├── templates/                      # File templates for new projects
│   │   ├── config.json.template
│   │   └── README.md.template
│   └── creator.py                      # Project creation logic
│
├── src/                                # Application source code
│   │
│   ├── database/                       # Database setup and initialization
│   │   ├── __init__.py
│   │   ├── connection.py               # DB connection, WAL mode configuration
│   │   └── __init__.py
│   │
│   ├── employee/                       # Everything related to Employee entity
│   │   ├── __init__.py
│   │   ├── models.py                   # Employee, Caces, MedicalVisit, OnlineTraining
│   │   ├── queries.py                  # Complex database queries (classmethods)
│   │   ├── calculations.py             # Business logic (expiration dates, seniority)
│   │   └── validators.py               # Data validation logic
│   │
│   ├── lock/                           # Everything related to locking mechanism
│   │   ├── __init__.py
│   │   ├── models.py                   # AppLock model
│   │   └── manager.py                  # Lock acquisition, heartbeat, release
│   │
│   ├── export/                         # Everything related to Excel exports
│   │   ├── __init__.py
│   │   ├── excel.py                    # Excel generation with formatting
│   │   └── templates.py                # Column definitions, styles, templates
│   │
│   ├── ui/                             # Flet interface
│   │   ├── __init__.py
│   │   ├── app.py                      # Flet entry point
│   │   ├── views/                      # Different views
│   │   │   ├── employees.py
│   │   │   ├── employee_detail.py
│   │   │   ├── documents.py
│   │   │   └── alerts.py
│   │   └── widgets/                    # Reusable UI components
│   │       ├── employee_card.py
│   │       ├── status_badge.py
│   │       └── dialogs.py
│   │
│   ├── utils/                          # Pure utility functions (stateless helpers)
│   │   ├── __init__.py
│   │   ├── files.py                    # File operations (copy, rename, sanitize)
│   │   ├── dates.py                    # Date manipulations
│   │   ├── config.py                   # Config JSON loader
│   │   └── log.py                      # Logger setup
│   │
│   └── main.py                         # Application entry point
│
├── tests/                              # Unit and integration tests
│   ├── __init__.py
│   ├── test_employee/
│   │   ├── test_models.py
│   │   ├── test_queries.py
│   │   └── test_calculations.py
│   ├── test_lock/
│   │   └── test_manager.py
│   └── test_export/
│       └── test_excel.py
│
├── build/                              # Build scripts
│   ├── build.py                        # PyInstaller script
│   └── build.spec                      # PyInstaller configuration
│
├── .gitignore
├── pyproject.toml                      # uv configuration (dependencies, metadata)
├── README.md                           # Development repository documentation
└── docs/
    ├── PROJECT.md                      # Project specifications
    ├── PROJECT_STRUCTURE.md            # This file
    ├── ARCHITECTURE.md                 # Architecture decisions (to be created)
    └── API.md                          # Internal API documentation (to be created)
```

## 2. Deployed Project Structure (Generated by Bootstrapper)

This structure is created by the bootstrapper and deployed to shared network drives.

```
[Project_Name]/                         # Example: "Gestion_Salaries_2025"
│
├── data/                               # Instance data
│   ├── employees.db                    # SQLite database
│   └── db_version.txt                  # Schema version (optional)
│
├── documents/                          # Uploaded files
│   ├── caces/                          # CACES certificates (PDFs)
│   ├── medical/                        # Medical visit certificates
│   ├── training/                       # Training certificates
│   └── avatars/                        # Employee photos
│
├── exports/                            # Generated Excel exports
│   └── .gitkeep
│
├── logs/                               # Application logs
│   └── .gitkeep
│
├── src/                                # Application code (compiled or bundled)
│   └── employee_manager.exe            # Standalone executable
│
├── config.json                         # Instance-specific configuration
│
└── README.md                           # User instructions
```

## 3. Architecture Principles

### Entity-Oriented Design

The codebase follows an **entity-oriented** approach where each major domain concept has its own module containing all related logic:

- **`employee/`**: Contains everything related to employees (models, queries, calculations, validations)
- **`lock/`**: Contains everything related to the locking mechanism
- **`export/`**: Contains everything related to Excel exports

This is **not** a layered architecture with separate models/services/repositories. Instead, it's a domain-driven approach where:

- Models know how to query themselves (classmethods)
- Models know how to calculate their properties (methods, properties)
- Models know how to validate themselves (validators)
- UI talks directly to entities
- Utils contain only stateless helper functions

### Component Responsibilities

#### `employee/models.py`
- Define database schema using Peewee ORM
- Include **business logic methods** (classmethods and instance methods)
- Provide **domain-specific queries** as class methods
- Calculate **computed properties** (e.g., `full_name`, `seniority`, `expiration_date`)

Example:
```python
class Employee(Model):
    first_name = CharField()
    last_name = CharField()

    @classmethod
    def active(cls):
        return cls.select().where(cls.current_status == 'active')

    @property
    def full_name(self):
        return f"{self.first_name} {self.last_name}"

    def add_caces(self, kind, completion_date, document_path):
        """Business logic for adding a CACES certification"""
        # Implementation here
```

#### `employee/queries.py`
- Complex multi-table queries
- Optimized queries for specific use cases
- Queries that involve joins or aggregations

#### `employee/calculations.py`
- Business logic calculations (seniority, expiration dates)
- Alert threshold calculations
- Status determination logic

#### `employee/validators.py`
- Data validation rules
- Custom validators for Peewee fields
- Business rule enforcement

#### `lock/manager.py`
- Lock acquisition and release
- Heartbeat mechanism (updates `last_heartbeat` every 30s)
- Stale lock detection and cleanup
- Thread-safe operations

#### `export/excel.py`
- Excel file generation
- Conditional formatting for alerts
- Multiple sheet generation
- Style application

#### `ui/`
- Display data to users
- Capture user input
- **Interact directly with entities** (no intermediate service layer)
- Manage application state

#### `utils/`
- **Pure functions only** (no classes)
- Stateless helpers for file operations, date manipulations, logging
- No business logic

### No Explicit Patterns

The codebase avoids naming patterns explicitly:
- ❌ No `*Repository`, `*Service`, `*Handler`, `*Manager` classes (except where genuinely needed like `lock/manager.py`)
- ❌ No `*Mixin` classes
- ✅ Entity-focused naming: modules are named by what they manage, not by architectural pattern
- ✅ Models contain their own behavior (good OOP)
- ✅ Functions over classes for simple utilities (Pythonic)

### Domain Example

```python
# Instead of:
employee_service.get_active_employees()
employee_service.calculate_seniority(employee)
file_handler.copy_file()

# We have:
Employee.active()
employee.seniority
copy_to_target()
```

### Bootstrapper Isolation

The bootstrapper is a separate utility that:
- Creates new project instances from templates
- Is not distributed with the compiled application
- Is used only by administrators to set up new projects

### Dependencies Management

- **Development**: Uses `uv` with virtual environment (`.venv/` in development repo only)
- **Production**: PyInstaller bundles all dependencies into the executable
- **Deployed projects**: Do not contain `.venv/` or require Python installation

## 4. File Naming Conventions

### Documents (Stored in `documents/`)

Uploaded files are automatically renamed using standardized patterns:

- **CACES**: `CACES_{EmployeeLastName}_{Kind}_{CompletionDate}.pdf`
- **Medical**: `MEDICAL_{EmployeeLastName}_{VisitType}_{VisitDate}.pdf`
- **Training**: `TRAINING_{EmployeeLastName}_{Title}_{CompletionDate}.pdf`
- **Avatars**: `AVATAR_{EmployeeLastName}_{EmployeeFirstName}.ext`

### Exports (Stored in `exports/`)

Excel exports follow the pattern defined in `config.json`:
- Default: `employees_export_{date}.xlsx`
- `{date}` is replaced with ISO date format (YYYY-MM-DD)

## 5. Configuration File

The `config.json` file controls instance-specific behavior:

```json
{
  "alert_thresholds_days": [30, 60, 90],
  "lock_timeout_minutes": 15,
  "export_filename_template": "employees_export_{date}.xlsx",
  "roles": ["Préparateur", "Réceptionnaire", "Cariste"],
  "workspaces": ["Quai", "Zone A", "Zone B", "Bureau"],
  "log_level": "INFO"
}
```

This file is:
- Created by the bootstrapper from a template
- Editable by administrators (requires app restart)
- Not tracked in version control (instance-specific)
- Loaded at application startup

## 6. Build and Distribution

### Development Workflow

1. Developers work in the `simple-employee-manager/` repository
2. Code changes are tested with `pytest`
3. When ready, run `build/build.py` to create the executable

### Distribution

1. The compiled `employee_manager.exe` is placed in the project's `src/` folder
2. The entire project folder is copied to the network share
3. Users run the executable from the network location

### Updates

To update the application:
1. Build a new executable
2. Replace only the `src/employee_manager.exe` file
3. Data, documents, and configuration remain intact

## 7. Key Design Decisions

### Why Entity-Oriented Over Layered Architecture?

1. **Better OOP**: Objects contain both data and behavior
2. **More Pythonic**: Leages Peewee's powerful ORM capabilities
3. **Less Indirection**: No unnecessary service layer
4. **Easier to Navigate**: All employee-related code is in `employee/`
5. **Simpler**: Fewer files, clearer responsibilities

### Why Not Services/Repositories?

- Adds unnecessary abstraction layers
- Creates "anemic domain models" (models without behavior)
- Java/Spring patterns don't translate well to Python
- Peewee already provides much of what services/repositories would do

### Why Functions Over Classes in Utils?

- Simple operations don't need classes
- Functions are more Pythonic for stateless operations
- Easier to test and reason about
- Follows Python's `utils.py` convention
